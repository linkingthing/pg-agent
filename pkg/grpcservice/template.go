package grpcservice

import (
	"bytes"
	"text/template"
)

const (
	PG_HBA_CONF = `#~lx-----------------------------------------------------------------------------
# PG HBA CONFIG
#------------------------------------------------------------------------------

#test for HA remote access
host 	all  		all			{{.IP}}/32            trust			

# these configuration options have been removed from their standard location and
# placed here so that Pagoda Box could override them with the neccessary values
# to configure redundancy.

# IMPORTANT: these settings will always be overriden when the server boots. They
# are set dynamically and so should never change.

host    replication     {{.User}}        {{.IP}}/32            trust`

	PG_CONF = `#~lx-----------------------------------------------------------------------------
# PG CONFIG
#------------------------------------------------------------------------------

# these configuration options have been removed from their standard location and
# placed here so that Pagoda Box could override them with the neccessary values
# to configure redundancy.

# IMPORTANT: these settings will always be overriden when the server boots. They
# are set dynamically and so should never change.

listen_addresses = '0.0.0.0'      # what IP address(es) to listen on;
                                  # comma-separated list of addresses;
                                  # defaults to 'localhost'; use '*' for all
                                  # (change requires restart)
port = {{.Port}}                     # (change requires restart)
wal_level = hot_standby           # minimal, archive, or hot_standby
                                  # (change requires restart)
archive_mode = on                 # allows archiving to be done
                                  # (change requires restart)
archive_command = 'exit 0'        # command to use to archive a logfile segment
                                  # placeholders: \%p = path of file to archive
                                  #               \%f = file name only
                                  # e.g. 'test ! -f /mnt/server/archivedir/\%f && cp \%p /mnt/server/archivedir/\%f'
max_wal_senders = 10              # max number of walsender processes
                                  # (change requires restart)
wal_keep_segments = 32          	# in logfile segments, 16MB each; 0 disables
hot_standby = on                  # "on" allows queries during recovery
                                  # (change requires restart)
shared_buffers = 128MB
fsync = off 
synchronous_commit = off 

`

	PG_EXTENSIONS_FOR_MASTER_CONF = `
# added only the the node running postgres as 'master'
synchronous_standby_names = slave # standby servers that provide sync rep
                                  # comma-separated list of application_name
                                  # from standby(s); '*' = all
`

	PG_RECOVERY_CONF = `#~lx-----------------------------------------------------------------------------
# PG RECOVERY CONFIG
#------------------------------------------------------------------------------

# IMPORTANT: this config file is dynamically generated by Pagoda Box for redundancy
# any changes made here will be overriden.

# When standby_mode is enabled, the PostgreSQL server will work as a standby. It
# tries to connect to the primary according to the connection settings
# primary_conninfo, and receives XLOG records continuously.
standby_mode = on
primary_conninfo = 'host={{.Host}} port={{.Port}} application_name=slave'

# restore_command specifies the shell command that is executed to copy log files
# back from archival storage. This parameter is *required* for an archive
# recovery, but optional for streaming replication. The given command satisfies
# the requirement without doing anything.
restore_command = 'exit 0'
`
)

func compileTemplate(templateStr string, values interface{}) (string, error) {
	buf := new(bytes.Buffer)
	t := template.Must(template.New("compiled_template").Parse(templateStr))
	if err := t.Execute(buf, values); err != nil {
		return "", err
	}

	return buf.String(), nil
}
